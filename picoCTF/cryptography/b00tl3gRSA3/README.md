# b00tl3gRSA3

## Description

Why use p and q when I can use more? Connect with nc jupiter.challenges.picoctf.org 3726.
## Hint(s)

1. There's more prime factors than p and q, finding d is going to be different.

## Writeup 
Alright, i started this challenge by doing research about multi-prime RSA and came across a couple of articles (such as : [this](https://crypto.stackexchange.com/questions/67043/what-is-multi-prime-rsa-rsa-mp))
In simple words, you can use multiple prime numbers in rsa instead of just P & Q. 


first we need to start by factorizing N, for this we use [this website](https://www.alpertron.com.ar/ECM.HTM)


we input N and press factor.
After it's done, we take the numbers and calculate phi (we do this by taking each number and subtract 1 from them)
```
(344 digits) = 8983 155053 × 9055 017211 × 9204 012253 × 9328 345363 × 9646 063099 × 9791 437727 × 9807 628063 × 10084 916293 × 10101 790271 × 10332 986813 × 10443 343511 × 11193 989951 × 12092 580893 × 12188 829743 × 12593 190881 × 12644 938081 × 12729 317543 × 13324 377881 × 13751 624429 × 14396 144911 × 14467 748279 × 14575 420687 × 14603 938123 × 15243 666059 × 15557 742307 × 15806 910499 × 16035 948007 × 16248 676949 × 16387 805719 × 16664 880961 × 16806 905441 × 17032 702307 × 17052 390041 × 17079 523243
```

Would turn into : 
```
phi=8983155052*9055017210*9204012252*9328345362*9646063098*9791437726*9807628062*10084916292*10101790270*10332986812*10443343510*11193989950*12092580892*12188829742*12593190880*12644938080*12729317542*13324377880*13751624428*14396144910*14467748278*14575420686*14603938122*15243666058*15557742306*15806910498*16035948006*16248676948*16387805718*16664880960*16806905440*17032702306*17052390040*17079523242
```

and from there, we can use a simple script to get the flag printed for us (i got the script from [here](https://ctf.samsongama.com/ctf/crypto/picoctf19-b00tl3gRSA3.html))
```py
from pwn import *

phi=8983155052*9055017210*9204012252*9328345362*9646063098*9791437726*9807628062*10084916292*10101790270*10332986812*10443343510*11193989950*12092580892*12188829742*12593190880*12644938080*12729317542*13324377880*13751624428*14396144910*14467748278*14575420686*14603938122*15243666058*15557742306*15806910498*16035948006*16248676948*16387805718*16664880960*16806905440*17032702306*17052390040*17079523242

c=19530525278078636247042208967937811172904196954610726714380516953848747099036847569044230257536854091664157113888544734143166860052242565201839454697803946124921098189201500503020435365941098866934879762745910181919222345072391236980937071029185123724338659758116392597393811658154713846016521463281345405885966250069125711767921055591326473837
n= 42974448279670014720827359626227321059513769656660836561597450563859154323297809783789634894528878663437433361660367482655291592537788596585666492512519227077964549415799851358311957150847535146285985286509804417163423676698670086407679924377125671350726617774766045324997768516797310729027203742637499361043956781422508925711141099331334390511

e = 65537



def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

d = modinv(e, phi) # c^d = m 
m = pow(c, d, n)
flag = unhex(hex(m)[2:])
print(flag)
```
that prints
```py
b'picoCTF{too_many_fact0rs_8606199}'
```
Very straightforward & interesting challenge, i had fun doing this.



